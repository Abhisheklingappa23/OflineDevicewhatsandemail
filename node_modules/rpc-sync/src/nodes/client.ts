import https from "https";
import http from "http";
import url from "url";
import fs from "fs";

import { ReactTypeScript } from "../generators/reactTypeScript/reactTypeScript";
import { TypeScript } from "../generators/typeScript/typeScript";
import { Dart } from "../generators/dart/dart";
import { VisualBasic } from "../generators/visualBasic/visualBasic";

export const generators: any = { ReactTypeScript, TypeScript, Dart, VisualBasic};

export  interface ISchema{

}

export interface ISchemaUpdate {
  schema: any;
  version: string;
}

export interface IClientSchemaConfig {
  configName: string;
  url: string;
  secret?: string;
  srcUrl?: string;
  docsUrl?: string;
  destSchemaOutput?:string;
  destSchemaOutputPretty?:boolean;
  output: string;
  namespace: string;
  generator: ILanguageGenerator;
  target: string;
}

export interface ILanguageGenerator {
  getHeader(options: IClientSchemaConfig, version: string): Promise<string>;
  generateClassEntity(
    options: IClientSchemaConfig,
    entity: any,
    enums: string[],
    types: string[],
    declarations: any[],
  ): string;
  generateInterfaces(
    options: IClientSchemaConfig,
    entity: any,
    enums: string[],
    types: string[]
  ): string;
  generateEnums(options: IClientSchemaConfig, entity: any): string;
  generateMethods(options: IClientSchemaConfig, apis: any[]): string;
  generateFooter(
    options: IClientSchemaConfig,
    enums: string[],
    types: string[],
    entities: any[],
  ): string;
}

const fetchSchema = (schemaOptions: IClientSchemaConfig) => {
  return new Promise<ISchemaUpdate>((accept, reject) => {
    let srcUrl = schemaOptions.srcUrl;

    console.log("Fetching schema..", srcUrl);

    if (schemaOptions.secret !== null && schemaOptions.secret !== undefined) {
      if (!srcUrl.endsWith("/")) {
        srcUrl = srcUrl + "/";
      }
      srcUrl = srcUrl + schemaOptions.secret;
    }

    const uri = url.parse(srcUrl);
    const options: any = {
      host: uri.hostname,
      port: parseInt(uri.port),
      path: uri.path,
    };

    const req = (uri.protocol == "https:" ? https : http)
      .get(options, (res) => {
        res.setEncoding("utf8");

        let content = "";

        res.on("data", function (chunk) {
          content += chunk;
        });

        res.on("end", function () {
          if (res.statusCode != 200) {
            reject(new Error(`Error ${res.statusCode} ${content}`));
            return;
          }
          try {
            const jobj = JSON.parse(content);
            console.log("Processing schema..", schemaOptions.srcUrl);
            let schemaVersion = (
              res.headers["schema-version"] || ""
            ).toString();
            if (schemaVersion.length == 0) {
              schemaVersion = "<version not detected>";
            }
            accept({
              schema: jobj,
              version: schemaVersion,
            });
          } catch (ex) {
            reject(ex);
          }
        });
      })
      .on("error", (err) => {
        reject(err);
      });
  });
};

const synchronizeSchema = (schemaOptions: IClientSchemaConfig) => {
  return new Promise<ISchemaUpdate>((accept, reject) => {
    fetchSchema(schemaOptions)
      .then(async (update: ISchemaUpdate) => {
        accept(update);
      })
      .catch((e) => {
        reject(e);
      });
  });
};

export const generateClientSchemaFromJson = (
  schemaOptions: IClientSchemaConfig,
  update: ISchemaUpdate
) => {
  return new Promise<void>((accept, reject) => {
    const schema = update.schema;

    schemaOptions.generator
      .getHeader(schemaOptions, update.version)
      .then((header) => {
        try {
          const keys = Object.keys(schema);

          let src = `// Auto generated using 'rpc-sync' do not edit directly\r// Target: ${
            schemaOptions.target
          }\r// Version: ${
            update.version
          }\r// Refreshed: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\r\r// Docs: ${
            schemaOptions.docsUrl
          }\r// Source: ${schemaOptions.srcUrl}\r\r${header}
           
        `;

        if(schemaOptions.target=="VisualBasic"){
          src = src.replace(new RegExp("// ","g"),"'");
        }
      
          const enumNames: string[] = [];
          const typeNames: string[] = [];
          const decs: any[] = [];

          keys.forEach((key) => {
            const def = schema[key];
            def.declarations = def.declarations || [];
            for (const dec of def.declarations) {
              if (dec.isExported == true) {
                dec.members = dec.members || [];
                decs.push(dec);
                typeNames.push(dec.name);
              }
            }
          });

          keys.forEach((key) => {
            const def = schema[key];
            def.declarations = def.declarations || [];
            for (const dec of def.declarations) {
              if (dec.isExported == true) {
                dec.methods = dec.methods || [];

                if (dec.methods.length > 0) {
                  if (key.length > 0) {
                    typeNames.push(key);
                  }
                }
              }
            }
          });

          //Generate enums
          keys.forEach((key) => {
            const def = schema[key];
            def.declarations = def.declarations || [];
            for (const dec of def.declarations) {
              if (dec.isExported == true) {
                dec.members = dec.members || [];
                if (dec.members.length > 0) {
                  enumNames.push(dec.name);

                  src =
                    src +
                    schemaOptions.generator.generateEnums(schemaOptions, dec);
                }
              }
            }
          });

          const entities:string[] = [];
          //Generate classes
          keys.forEach((key) => {
            const def = schema[key];
            if (def.entity == true) {
              def.declarations = def.declarations || [];

              for (const dec of def.declarations) {
                if (dec.isExported == true) {
                  dec.members = dec.members || [];
                  dec.properties = dec.properties || [];
                  if (dec.members.length == 0 && dec.properties.length > 0) {
                    entities.push(dec["name"]);
                    src =
                      src +
                      schemaOptions.generator.generateClassEntity(
                        schemaOptions,
                        dec,
                        enumNames,
                        typeNames,
                        decs,
                      );
                  }
                }
              }
            }
          });

          //Generate interfaces
          keys.forEach((key) => {
            const def = schema[key];
            if (def.entity != true) {
              def.declarations = def.declarations || [];
              for (const dec of def.declarations) {
                if (dec.isExported == true) {
                  dec.properties = dec.properties || [];
                  dec.members = dec.members || [];
                  if (
                    dec.properties.length > 0 ||
                    (dec.properties.length == 0 &&
                      dec.members.length == 0 &&
                      dec.name.startsWith("I"))
                  ) {
                    src =
                      src +
                      schemaOptions.generator.generateInterfaces(
                        schemaOptions,
                        dec,
                        enumNames,
                        typeNames
                      );
                  }
                }
              }
            }
          });

          const apis: any[] = [];

          //Generate APIs
          keys.forEach((key) => {
            const def = schema[key];
            if (def.entity != true) {
              def.declarations = def.declarations || [];
              for (const dec of def.declarations) {
                if (dec.isExported == true) {
                  dec.methods = dec.methods || [];

                  if (dec.methods.length > 0) {
                    dec["alias"] = key;
                    apis.push(dec);
                  }
                }
              }
            }
          });

          src =
            src + schemaOptions.generator.generateMethods(schemaOptions, apis);


            src =
            src +
            schemaOptions.generator.generateFooter(
              schemaOptions,
              enumNames,
              typeNames,
              entities,
            );


          fs.writeFile(schemaOptions.output, src, (err) => {
            if (err) {
              reject(err);
              return;
            }
            accept();
          });
        } catch (e) {
          reject(e);
        }
      })
      .catch((e) => {
        reject(e);
      });
  });
};

export const generateClientSchema = (config: IClientSchemaConfig) => {
  return new Promise<ISchemaUpdate>((accept, reject) => {
    config.target = config.target || "ReactTypeScript";

    if (config.generator == null) {
      config.generator = generators[config.target];
    }

    if (config.generator == null) {
      reject(new Error(`Unsupported target ${config.target}`));
      return;
    }

    console.log("Target:", config.target);

    config.output = config.output || "";
    config.namespace = config.namespace || "RPC";

    config.url = config.url || "";

    if (config.url.length == 0) {
      reject(new Error(`[url] parameter missing in ${config.configName}`));
      return;
    }
    if (config.output.length == 0) {
      reject(new Error(`[output] parameter missing in ${config.configName}`));
      return;
    }

    if (!config.url.endsWith("/")) {
      config.url = `${config.url}/`;
    }

    config.srcUrl = config.srcUrl || "";
    config.docsUrl = config.docsUrl || "";

    if (config.srcUrl.length == 0) {
      config.srcUrl = `${config.url}json/`;
    }

    if (config.docsUrl.length == 0) {
      config.docsUrl = `${config.url}docs/`;
    }

    synchronizeSchema(config)
      .then((schema) => {
        generateClientSchemaFromJson(config, schema)
          .then(() => {
            console.log(config.namespace, "generated:", config.output);

            if(config.destSchemaOutput==null){
              accept(schema);
              return;
            }

            fs.writeFile(config.destSchemaOutput, config.destSchemaOutputPretty==true ? JSON.stringify(schema,null,2) : JSON.stringify(schema), ()=>{
              accept(schema);
            });

          })
          .catch((e) => {
            console.error(e);
            reject(e);
          });
      })
      .catch((e) => {
        console.error(e);
        reject(e);
      });
  });
};
