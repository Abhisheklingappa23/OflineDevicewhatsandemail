/* eslint-disable  @typescript-eslint/no-explicit-any */
/* eslint-disable  @typescript-eslint/no-unused-vars */

import https from "https";
import http from "http";
import url from "url";

export class ErrorWithStatusCode extends Error {
  statusCode: number | undefined;
  constructor(message: string, statusCode: number | undefined) {
    super(message);
    this.statusCode = statusCode;
  }
}
export enum RequestStatus {
  idle = 0,
  loading = 1,
  loaded = 2,
  error = 3,
}

export interface IContext {
  url: string;
  headers?: any;
  schemaVersion?: string;
  requestHandler?: (
    context: IContext,
    schemaVersion: string,
    parameters: any,
    accept: (value: any) => void,
    reject: (reason: any) => void
  ) => void;
}

export interface IRequestState<T, P> {
  data: T | null;
  status: RequestStatus;
  err: Error | unknown | null;
  params: P | null;
  callBack: (value: T | null) => void;
  context: IContext | null;
}

export const ErrorToString=(err: Error | unknown | null)=>{
  if(err==null) return "";
  if((err as Error).message!=null) return (err as Error).message;
  return (err as Record<string, unknown>).toString();
}

const createContext = (context: IContext, alias: string, method: string) => {
  const subContext = Object.assign({}, context);
  if (subContext.url.endsWith("/") === false) {
    subContext.url = subContext.url + "/";
  }
  subContext.url = subContext.url + alias + "/" + method + "/";
  return subContext;
};

const decodeResult = (value: any) => {
  if (value !== null && value !== undefined) {
    if (value.hasOwnProperty("primitive")) {
      return value["primitive"];
    }
  }
  return value;
};

const defaultRequestHandler = (
  context: IContext,
  schemaVersion: string,
  parameters: any,
  accept: (value: any) => void,
  reject: (reason: any) => void
) => {
  parameters = parameters || {};
  const data = JSON.stringify(parameters);

  const uri = url.parse(context.url);

  const options = {
    host: uri.hostname,
    port: parseInt(uri.port || ""),
    path: uri.path,
    method: "POST",
    headers: Object.assign(
      {
        "Content-Type": "application/json",
        "Content-Length": data.length,
        "schema-version": schemaVersion,
        timestamp: new Date().toISOString(),
      },
      context.headers || {}
    ),
  };

  const request = (uri.protocol === "https:" ? https : http)
    .request(options, (res) => {
      res.setEncoding("utf8");

      let content = "";

      res.on("data", function (chunk) {
        content += chunk;
      });

      res.on("end", function () {
        const serverSchemaVersion = (
          res.headers["schema-version"] || ""
        ).toString();

        if (serverSchemaVersion.length > 0) {
          if (serverSchemaVersion !== schemaVersion) {
            console.warn(
              "The client",
              `v${schemaVersion}`,
              "is out of date. The server expects version",
              `v${serverSchemaVersion}`
            );
          }
        }

        let jobj;

        try {
          jobj = JSON.parse(content);
        } catch (ex) {
          jobj = null;
          if (res.statusCode == 200) {
            reject(new ErrorWithStatusCode(ErrorToString(ex), res.statusCode));
            return;
          }
        }

        if (res.statusCode !== 200) {
          if (jobj == null) {
            jobj = { error: res.statusMessage };
          }
          reject(new ErrorWithStatusCode(jobj.error, res.statusCode));
          return;
        }

        try {
          accept(jobj);
        } catch (ex) {
          reject(new ErrorWithStatusCode(ErrorToString(ex), res.statusCode));
        }
      });
    })
    .on("error", (err) => {
      reject(new ErrorWithStatusCode(ErrorToString(err), 0));
    });
  request.write(data);
  request.end();
};
