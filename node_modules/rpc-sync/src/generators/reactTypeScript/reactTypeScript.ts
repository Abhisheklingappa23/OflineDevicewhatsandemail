import { IClientSchemaConfig, ILanguageGenerator } from "../../nodes/client";
import fs from "fs";
import path from "path";

export const ReactTypeScript: ILanguageGenerator = {

    getHeader(options: IClientSchemaConfig, version: string) {
        return new Promise<string>((accept, reject) => {
            fs.readFile(path.join(__dirname, "../../../src/generators/reactTypeScript/", "reactTypeScriptTemplate.ts"), (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }

                accept(`export const schemaVersion = "${version}";\r\rimport { useEffect, useState } from 'react';\r${data.toString("utf8")}`);
            });
        });
    },
    generateFooter(options:IClientSchemaConfig, enums:string[], types:[], generateFooter:[]){
        return "";
    },
    generateClassEntity(options: IClientSchemaConfig, declaration: any, declarations: any[],) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}${prop.name}${prop.isOptional == true ? '?' : ''}:${prop.type};
        `;
        }
        let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateInterfaces(options: IClientSchemaConfig, declaration: any) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}${prop.name}${prop.isOptional == true ? '?' : ''}:${prop.type};
        `;
        }
        let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateEnums(options: IClientSchemaConfig, declaration: any) {
        let props = "";
        declaration.members = declaration.members || [];
        for (const member of declaration.members) {
            props = `${props}${member},
        `;
        }
        let src = `
    export enum ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateMethods(options: IClientSchemaConfig, apis: any[]) {
        let src = `
    export const ${options.namespace} = {
   
    hooks : {
        `;

        for (let a = 0; a < apis.length; a++) {
            const declaration = apis[a];
            declaration.methods = declaration.methods || [];

            src = src + `${declaration.alias}:{
            `;
            for (let m = 0; m < declaration.methods.length; m++) {
                const method = declaration.methods[m];
                let props = "";

                for (let i = 0; i < method.parameters.length; i++) {
                    const param = method.parameters[i];
                    if (props.length > 0) {
                        props = `${props}, `;
                    }
                    props = `${props}${param.name}: ${param.type}`;
                }

                const mainParam = method.parameters[1] || { "name": "parameters" };


                let methodParamType = method.type;
                if (methodParamType.indexOf("Promise<") !== -1) {
                    methodParamType = methodParamType.substring(8);
                    methodParamType = methodParamType.substring(0, methodParamType.length - 1);
                }



                src = src + `
            ${method.name}:() => {
                const emptyCallBack = ()=>{
                    console.log("no callback defined");
                };
                 const [state, setState] = useState<IRequestState<${methodParamType}, ${mainParam.type}>>({
                    data:null,
                    status: RequestStatus.idle,
                    err: null,
                    params: null,
                    callBack: emptyCallBack,
                    context:null
                });
 
                useEffect(()=>{
                  
                   let didCancel = false;

                    const fetchData = async ()=>{
                        try {
                           
                            if(state.context !=null && state.params!=null && state.callBack!=null){
                                const ctx = createContext(
                                    state.context, 
                                    "${declaration.alias}",
                                    "${method.name}");
 
                                const result = await new ${method.type}(
                                    (a, r)=>(state.context ==null ? defaultRequestHandler : state.context.requestHandler || defaultRequestHandler)
                                        (ctx, 
                                        schemaVersion, 
                                        state.params, 
                                        (v)=>{a(decodeResult(v))}, r));

                                if(didCancel==true){
                                    console.log("Hook cancelled after fetch [${method.name}]");
                                    return;
                                }

                                const cb = state.callBack;
                                setState({
                                    ...state,
                                    status:RequestStatus.loaded,
                                    data: result,
                                    params: null,
                                    err: null,
                                    callBack: emptyCallBack,
                                });
                                cb(result);
                            }
                        } catch (e) {
                            console.warn(e);
                             if(didCancel==true){return;}
                            const cb = state.callBack;
                            setState({
                                ...state,
                                status:RequestStatus.error,
                                data: null,
                                params: null,
                                err: e,
                                callBack: emptyCallBack,
                            });
                            cb(null);
                        }
                    };
                   
                    fetchData();

                    return () => {
                         didCancel = true;
                    };
                },[state.params]);

                const send = (context: IContext, ${mainParam.name}: ${mainParam.type}, callBack?: (value: ${methodParamType} | null)=>void) => {
                    setState({...state, context: context, data:null, status:RequestStatus.loading, params: {...${mainParam.name}}, callBack: (value)=>{
                        if(callBack!=null){
                            callBack(value);
                        }
                    }});
                };

                return {...state, send };
            }${m != declaration.methods.length - 1 ? "," : ""}
 
            `;
            }

            src = src + `
        }${a != apis.length - 1 ? "," : ""}
    
        `;
        }
        src = src + `
    },
};`


        return src;
    }
};
