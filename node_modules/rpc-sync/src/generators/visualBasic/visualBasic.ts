import { IClientSchemaConfig, ILanguageGenerator } from "../../nodes/client";
import fs from "fs";
import path from "path";


const typeMap:any = {
    "number":"Double",
    "unknown":"Object"
};
const typeKeys = Object.keys(typeMap);

const convertTypeToVB = (type:string)=>{
    if(type==null){
        type = "Object";
    }
    if(type.indexOf("{")!=-1 || type.indexOf("}")!=-1 ){
        type="Object";
    }
  if(type.indexOf(" ")!=-1){
    type = type.split(" ")[0];
  }
  if(type.split("<")[0]=="Record"){
    type = "Object";
  }
 const isArray = type.indexOf("[]")!=-1;
    if(isArray==true) type =type.replace("[]","");
    
    if(typeKeys.indexOf(type)!=-1){
    type = typeMap[type] as string;
    };
 
if(isArray){
    type = `Generic.List(of ${type})`;
}
    return type;
}
export const VisualBasic: ILanguageGenerator = {
    getHeader(options: IClientSchemaConfig, version: string) {
        return new Promise<string>((accept, reject) => {
            fs.readFile(path.join(__dirname, "../../../src/generators/visualBasic/", "visualBasicTemplate.vb"), (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }

                accept(`Module Schema\r\npublic const schemaVersion as string = "${version}"\r\nEnd Module\r\n${data.toString("utf8")}`);
            });
        });
    },
    generateFooter(options:IClientSchemaConfig, enums:string[], types:[], generateFooter:[]){
        return "";
    },
    generateClassEntity(options: IClientSchemaConfig, declaration: any, declarations: any[],) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}Public [${prop.name}] as ${convertTypeToVB(prop.type)}
        `;
        }
        let src = `
     Public Class ${declaration.name}
        ${props}
     End Class
    `;
        return src;
    },
    generateInterfaces(options: IClientSchemaConfig, declaration: any) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}Public [${prop.name}] as ${convertTypeToVB(prop.type)}
        `;
        }
        let src = `
    Public Class ${declaration.name}
        ${props}
    End Class
    `;
        return src;
    },
    generateEnums(options: IClientSchemaConfig, declaration: any) {
        let props = "";
        declaration.members = declaration.members || [];
        for (const member of declaration.members) {
            props = `${props}[${member}]
        `;
        }
        let src = `
    Public Enum ${declaration.name}
        ${props}
    End Enum
    `;
        return src;
    },
    generateMethods(options: IClientSchemaConfig, apis: any[]) {
        let src = `
      Public Class [${options.namespace}]
   
  
        `;

        for (let a = 0; a < apis.length; a++) {
            const declaration = apis[a];
            declaration.methods = declaration.methods || [];

            src = src + `Public Class [${declaration.alias}API]
            `;
            for (let m = 0; m < declaration.methods.length; m++) {
                const method = declaration.methods[m];
                let props = "";

                for (let i = 0; i < method.parameters.length; i++) {
                    const param = method.parameters[i];
                    if (props.length > 0) {
                        props = `${props}, `;
                    }
                    props = `${props}${param.name} as ${param.type}`;
                }

                const mainParam = method.parameters[1] || { "name": "parameters" };


                let methodParamType = method.type;
                if (methodParamType.indexOf("Promise<") !== -1) {
                    methodParamType = methodParamType.substring(8);
                    methodParamType = methodParamType.substring(0, methodParamType.length - 1);
                }


if(methodParamType!="void"){
    src = src + `
    Public Shared Function [${method.name}](${props}) as ${convertTypeToVB(methodParamType)}
        return Utility.RequestHandler(Of ${convertTypeToVB(methodParamType)})(context, String.Format("{0}/{1}", "${declaration.alias}", "${method.name}"), parameters)
    End Function
    `;
}
           


            }

            src = src + `
            End Class
    
        `;
        }
        src = src + `

    End Class`


        return src;
    }
};
