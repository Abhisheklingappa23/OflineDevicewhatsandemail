import { IClientSchemaConfig, ILanguageGenerator } from "../../nodes/client";
import fs from "fs";
import path from "path";

export const TypeScript: ILanguageGenerator = {
  getHeader(options: IClientSchemaConfig, version: string) {
    return new Promise<string>((accept, reject) => {
      fs.readFile(
        path.join(
          __dirname,
          "../../../src/generators/typeScript/",
          "TypeScriptTemplate.ts"
        ),
        (err, data) => {
          if (err) {
            reject(err);
            return;
          }
          accept(
            `export const schemaVersion = "${version}";\r\r${data.toString(
              "utf8"
            )}`
          );
        }
      );
    });
  },
  generateFooter(options:IClientSchemaConfig, enums:string[], types:[], generateFooter:[]){
    return "";
},
  generateClassEntity(
    options: IClientSchemaConfig,
    declaration: any,
    enums: string[],
    declarations: any[],
  ) {
    let props = "";
    declaration.properties = declaration.properties || [];
    for (const prop of declaration.properties) {
      props = `${props}${prop.name}${prop.isOptional == true ? "?" : ""}:${
        prop.type
      };
        `;
    }
    let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
    return src;
  },
  generateInterfaces(
    options: IClientSchemaConfig,
    declaration: any,
    enums: string[]
  ) {
    let props = "";
    declaration.properties = declaration.properties || [];
    for (const prop of declaration.properties) {
      props = `${props}${prop.name}${prop.isOptional == true ? "?" : ""}:${
        prop.type
      };
        `;
    }
    let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
    return src;
  },
  generateEnums(options: IClientSchemaConfig, declaration: any) {
    let props = "";
    declaration.members = declaration.members || [];
    for (const member of declaration.members) {
      props = `${props}${member},
        `;
    }
    let src = `
    export enum ${declaration.name}{
        ${props}
    }
    `;
    return src;
  },
  generateMethods(options: IClientSchemaConfig, apis: any[]) {
    let src = `
    export const ${options.namespace} = {

        requests:{
        `;

    for (let a = 0; a < apis.length; a++) {
      const declaration = apis[a];
      declaration.methods = declaration.methods || [];

      src =
        src +
        `${declaration.alias}:{
            `;
      for (let m = 0; m < declaration.methods.length; m++) {
        const method = declaration.methods[m];
        let props = "";

        for (let i = 0; i < method.parameters.length; i++) {
          const param = method.parameters[i];
          if (props.length > 0) {
            props = `${props}, `;
          }
          props = `${props}${param.name}: ${param.type}`;
        }

        const mainParam = method.parameters[1] || { name: "parameters" };

        src =
          src +
          `
            ${method.name}:(${props}) : ${method.type} => {
                return new ${
                  method.type
                }((a, r)=>(context.requestHandler || defaultRequestHandler)(createContext(context, "${
            declaration.alias
          }","${method.name}"),schemaVersion, ${
            mainParam.name
          }, (v)=>{a(decodeResult(v))}, r));
            }${m != declaration.methods.length - 1 ? "," : ""}
            `;
      }

      src =
        src +
        `
        }${a != apis.length - 1 ? "," : ""}
    
        `;
    }
    src =
      src +
      `
       
    }
};
`;

    return src;
  },
};
