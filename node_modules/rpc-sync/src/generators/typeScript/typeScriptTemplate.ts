/* eslint-disable  @typescript-eslint/no-explicit-any */
/* eslint-disable  @typescript-eslint/no-unused-vars */

import https from "https";
import http from "http";
import url from "url";

export class ErrorWithStatusCode extends Error {
    statusCode: number | undefined;
    constructor(message: string, statusCode: number | undefined) {
        super(message);
        this.statusCode = statusCode;
    }
}

export enum RequestStatus {
    idle = 0,
    loading = 1,
    loaded = 2,
    error = 3
}

export interface IContext {
    url: string;
    headers?: any;
    schemaVersion?: string;
    requestHandler?: (context: IContext, schemaVersion: string, parameters: any, accept: (value: any) => void, reject: (reason: any) => void) => void;
}

export interface IEffectOptions {
    useEffect: boolean;
}

const createContext = (context: IContext, alias: string, method: string) => {
    const subContext = Object.assign({}, context);
    if (subContext.url.endsWith("/") === false) { subContext.url = subContext.url + "/"; }
    subContext.url = subContext.url + alias + "/" + method + "/";
    return subContext;
};

const decodeResult = (value: any) => {
    if (value !== null && value !== undefined) {
        if (value.hasOwnProperty("primitive")) {
            return value["primitive"];
        }
    }
    return value;
};

const defaultRequestHandler = (context: IContext, schemaVersion: string, parameters: any, accept: (value: any) => void, reject: (reason: any) => void) => {
    parameters = parameters || {};
    const data = JSON.stringify(parameters);

    const uri = url.parse(context.url);

    const options = {
        host: uri.hostname,
        port: parseInt(uri.port || ""),
        path: uri.path,
        method: "POST",
        headers: Object.assign({
            'Content-Type': 'application/json',
            'Content-Length': data.length,
            'schema-version': schemaVersion,
            'User-Agent': 'rpc',
            'timestamp': new Date().toISOString()
        }, context.headers || {}),
    };

    const request = (uri.protocol === "https:" ? https : http).request(options, (res) => {

        res.setEncoding("utf8");

        let content = "";

        res.on("data", function (chunk) {
            content += chunk;
        });

        res.on("end", function () {
            const serverSchemaVersion = (res.headers["schema-version"] || "").toString();

            if (serverSchemaVersion.length > 0) {
                if (serverSchemaVersion !== schemaVersion) {
                    console.warn("Client schema is out of date. The server is running a different version of the API. Server:", serverSchemaVersion, "Client:", schemaVersion);
                }
            }

            let jobj;

            try {
                jobj = JSON.parse(content);
            } catch (ex) {
                jobj = null;
                if (res.statusCode == 200) {
                    reject(new ErrorWithStatusCode(ex.message, res.statusCode));
                    return;
                }
            }

            if (res.statusCode !== 200) {
                if (jobj == null) {
                    jobj = { error: res.statusMessage };
                }
                reject(new ErrorWithStatusCode(jobj.error, res.statusCode));
                return;
            }


            try {
                accept(jobj);
            } catch (ex) {
                reject(new ErrorWithStatusCode(ex.message, res.statusCode));
            }
        });

    }).on("error", (err) => {
        reject(new ErrorWithStatusCode(err.message, 0));
    });
    request.write(data);
    request.end();
}
