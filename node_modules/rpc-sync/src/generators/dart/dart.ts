import { IClientSchemaConfig, ILanguageGenerator } from "../../nodes/client";
import fs from "fs";
import path from "path";
 
const typeMapping: any = {
  number: "dynamic",
  string: "String?",
  String: "String?",
  boolean: "bool",
  undefined: "dynamic",
  unknown: "dynamic",
  Date: "dynamic",
  "Record<string,unknown>": "dynamic",
};

const primitiveTypes = ["bool", "String",  "String?", "string", "dynamic"];

const resolvePropertyType = (type: any) => {
  type = type ?? "";
 
  if(type.indexOf("{")!=-1){
    return "dynamic";
  }
  type = type || "";
  type = type.replace(/ /g, "");
  type = type.split("|")[0];

  if (type.length == 0) {
    type = "undefined";
  }
  if (typeMapping[type] != null) {
    type = typeMapping[type];
  }

  if (type.indexOf("[]") != -1) {
    type = type.replace("[]", "");
    if (typeMapping[type] != null) {
      type = typeMapping[type];
    }
    type = `List<${type}>`;
  }
  return type;
};

const generateProps = (declaration: any, enums: string[], types: string[]) => {
  declaration.properties = declaration.properties || [];

  let props: string = "";
  for (const prop of declaration.properties) {
    const type = resolvePropertyType(prop.type);
    const isList = type.indexOf("List<") != -1;
    let innerType = "";
    let isEnum = false;

    if (isList == true) {
      innerType = type.replace("List<", "");
      innerType = innerType.substring(0, innerType.length - 1);
      isEnum = enums.indexOf(innerType) != -1;
    } else {
      isEnum = enums.indexOf(type) != -1;
    }

    let getter = `${type} get ${prop.name} => props["${prop.name}"];`;
    let setter = `set ${prop.name}(${type} v) => props["${prop.name}"] = v;`;

    if (isList == true && isEnum == false && types.indexOf(innerType) != -1) {
      getter = `${type} get ${prop.name} => propertyToList<${innerType}>("${prop.name}", (p) => props["${prop.name}"]==null ? null : ${innerType}(props:p));`;
      setter = `set ${prop.name}(${type} v) => {props["${prop.name}"] = listToProperty(v)};`;
    } else if (isList == true && isEnum == false && types.indexOf(type) != -1) {
      getter = `${type} get ${prop.name} => propertyToList<${type}>("${prop.name}", (p) => ${type}(props:p).val());`;
      setter = `set ${prop.name}(${type} v) => {props["${prop.name}"] = v};`;
      setter = "";
    } else if (
      isList == false &&
      isEnum == false &&
      types.indexOf(type) != -1
    ) {
      getter = `${type}? get ${prop.name} => props["${prop.name}"]==null ? null : ${type}(props:props["${prop.name}"]);`;
      setter = `set ${prop.name}(${type}? v) {
        v==null ? props["${prop.name}"] = null : props["${prop.name}"] = v.props;
        v==null ? props["${prop.name}Id"] = null : props["${prop.name}Id"] = v.props["id"];
      }`;
    } else if (isList == false && isEnum == true) {
      getter = `${type} get ${prop.name}{
        return ${type}.values[props["${prop.name}"]];
      }`;
      setter = `set ${prop.name}(${type} v) => props["${prop.name}"] = v.index;`;
    } else if (isList == true && isEnum == true) {
      getter = `${type} get ${prop.name}{
        return props["${prop.name}"];
      }`;
      setter = `set ${prop.name}(${type} v) => props["${prop.name}"] = List.generate(
        v.length, (index) => ${innerType}.values.indexOf(v[index]));`;
    }else if (type=="bool"){
        getter = `${type} get ${prop.name} => isTrue(props["${prop.name}"]);`;
        setter = `set ${prop.name}(${type} v) => props["${prop.name}"] = v;`;
  
    }

    props = `${props}${getter}
        ${setter}
            `;
  }
  return props;
};

export const Dart: ILanguageGenerator = {
  getHeader(options: IClientSchemaConfig, version: string) {
    return new Promise<string>((accept, reject) => {
      fs.readFile(
        path.join(
          __dirname,
          "../../../src/generators/dart/",
          "dartTemplate.dart"
        ),
        (err, data) => {
          if (err) {
            reject(err);
            return;
          }
          accept(
            `// ignore_for_file: camel_case_types, non_constant_identifier_names, constant_identifier_names
import 'dart:convert';
import 'package:http/http.dart' as http;
const schemaVersion = "${version}";\r\r\r${data.toString("utf8")}`
          );
        }
      );
    });
  },
  generateClassEntity(
    options: IClientSchemaConfig,
    declaration: any,
    enums: string[],
    types: string[],
    declarations: any[],
  ) {
    return `
    class ${declaration.name} extends Serial{
        ${declaration.name}({props}) : super(props:props);
        static String entityName = "${declaration.name}";
        @override
        String get getEntityName => ${declaration.name}.entityName;
        ${generateProps(declaration, enums, types)}}
`;
  },
  generateInterfaces(
    options: IClientSchemaConfig,
    declaration: any,
    enums: string[],
    types: string[]
  ) {
    return `
    class ${declaration.name} extends Serial{
        ${declaration.name}({props}) : super(props:props);
        static String entityName = "${declaration.name}";
        @override
        String get getEntityName => ${declaration.name}.entityName;
        ${generateProps(declaration, enums, types)}}
`;
  },
  generateEnums(options: IClientSchemaConfig, declaration: any) {
    const escapeQuote = String.fromCharCode(96);
    let props = "    ";
    declaration.members = declaration.members || [];
    let index = 0;
    for (const member of declaration.members) {
      props = `${props}${member}_,
    `;
      index++;
    }
    let src = `
    enum ${declaration.name}{
${props}}
    `;
    return src;
  },
  generateMethods(options: IClientSchemaConfig, apis: any[]) {
    let src = `
    
    `;

    for (let a = 0; a < apis.length; a++) {
      const declaration = apis[a];
      declaration.methods = declaration.methods || [];
      const className =
        declaration.alias.substring(0, 1).toString().toUpperCase() +
        declaration.alias.substring(1);

      src = `${src}class _${className}API {
            `;
      for (let m = 0; m < declaration.methods.length; m++) {
        const method = declaration.methods[m];
        let props = "";

        for (let i = 0; i < method.parameters.length; i++) {
          const param = method.parameters[i];
          if (props.length > 0) {
            props = `${props}, `;
          }
          props = `${props}${param.name}: ${param.type}`;
        }

        const mainParam = method.parameters[1] || { name: "parameters" };

        let methodType = method.type;

        if (methodType.indexOf("Promise<") != -1) {
          methodType = methodType.replace("Promise<", "");
          methodType = methodType.substring(0, methodType.length - 1);
        }

        methodType = resolvePropertyType(methodType);

        let methodInnerType = "";

        if (methodType.indexOf("List<") != -1) {
          methodInnerType = methodType.replace("List<", "");
          methodInnerType = methodInnerType.substring(
            0,
            methodInnerType.length - 1
          );
        }

        let returnStatement = `
            return result==null ? null : ${methodType}(props: result);`;
        let assignment = `final result = `;

        if (primitiveTypes.indexOf(methodType) != -1) {
          returnStatement = `
            return result["primitive"];`;
        } else {
          if (methodType == "void") {
            assignment = "";
            returnStatement = "";
          } else {
            if (methodType.indexOf("List<") != -1) {
              if (primitiveTypes.indexOf(methodInnerType) == -1) {
                returnStatement = `
                    return Serial.objectToList<${methodInnerType}>(result, (p) => ${methodInnerType}(props:p).val());`;
              } else {
                returnStatement = `
                    return result;`;
              }
            }
          }
        }

        src =
          src +
          `
          Future<${methodType == "void" ? methodType : (methodType=="dynamic" ? "dynamic" :`${methodType.replace("?","")}?`)}> ${method.name}(IContext context, ${mainParam.type} ${mainParam.name}) async {
            ${assignment}await context.request("${declaration.alias}","${method.name}",${mainParam.name});${returnStatement}
          }
           `;
      }

      src =
        src +
        `
        }
    
        `;
    }

    src += `
class ${options.namespace}{
        `;
    for (let a = 0; a < apis.length; a++) {
      const declaration = apis[a];
      declaration.methods = declaration.methods || [];
      const className =
        declaration.alias.substring(0, 1).toString().toUpperCase() +
        declaration.alias.substring(1);

      src += `static _${className}API ${declaration.alias} = _${className}API();  
          `;
    }
    src += `}`;
    return src;
  },
  generateFooter(options:IClientSchemaConfig, enums:string[], types:string[], entities:string[]){
    let footer =  '';
    entities.forEach((entity)=>{
      footer = `${footer}
        case '${entity}': return ${entity}(props:props);`;
    });
    types.forEach((type)=>{
      if(type.startsWith("I") && enums.indexOf(type)==-1 && entities.indexOf(type)==-1){
        footer = `${footer}
        case '${type}': return ${type}(props:props);`;
      }
     
    });
    return `
      class EntityFactory{
        static dynamic createEntity(String className, {dynamic props}){
            switch(className){
                ${footer}
            }
            return null;
        }
      }
    `;
},
};
