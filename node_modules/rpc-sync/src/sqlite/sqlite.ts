const primitives = ["string","number","boolean"];

export const classNameToTableName  = (className:string)=>{
    let output = "";
    for(let i=0;i<className.length;i++){
        const isUpperCase = className[i].toUpperCase()==className[i];
        if(isUpperCase && output.length>0){
            output+= "_" + className[i]  ;
        }else{
            output+= className[i];
        }
    }
    return output.toLowerCase();
}

export const generateCreateStatement = (declaration:any, enums: string[],  types: string[])=>{
 
    let createFields = "";
    for (const prop of declaration.properties) {
        const type = prop.type;
        const innerType = prop.type.replace("[]","");
        const isList = type.indexOf("[]") != -1;
        const isObject = (types.indexOf(type)!=-1 || types.indexOf(innerType)!=-1) ;
        const isPrimitive = (primitives.indexOf(type)==-1 && primitives.indexOf(innerType)==-1) ;
        
        let isEnum = false;
    
        if (isList == true) {
          isEnum = enums.indexOf(innerType) != -1;
        } else {
          isEnum = enums.indexOf(type) != -1;
        }
        
      if(createFields.length>0){
        createFields = createFields + ", ";
      }
      if(prop.name=="id"){
        createFields = createFields + `${prop.name} INTEGER PRIMARY KEY`;
      }else{
          if(isEnum){
            createFields = createFields + `${prop.name} INTEGER`;
          }else if(isList){
            //createFields = createFields + `${prop.name}Id INTEGER`;
        }else if(isObject==true && isPrimitive==false){
            createFields = createFields + `${prop.name}Id INTEGER`;
          }else{
            createFields = createFields + `${prop.name} TEXT`;
          }
      }
    }
    return `CREATE TABLE ${classNameToTableName(declaration.name)} (${createFields})`;
}

export const generateSelectStatementJoin = (alias:string, declarations: any[],declaration:any, enums: string[],  types: string[])=>{
    if(alias==null){
        alias = classNameToTableName(declaration.name);
    }
    const fields:string[] = [];
    const joins:string[]  = [];

    for (const prop of declaration.properties) {
        const type = prop.type;
        const innerType = prop.type.replace("[]","");
        const isList = type.indexOf("[]") != -1;
        const isObject = (types.indexOf(type)!=-1 || types.indexOf(innerType)!=-1) ;
    
        let isEnum = false;
    
        if (isList == true) {
          isEnum = enums.indexOf(innerType) != -1;
        } else {
          isEnum = enums.indexOf(type) != -1;
        }

        if(isList==false && isObject==true && isEnum==false ){ 
            const fieldAlias = `${alias}_${prop.name}`;
           // fields.push(`${fieldAlias}Id`);
            joins.push(`LEFT JOIN ${classNameToTableName(innerType)} as ${fieldAlias} on ${fieldAlias}.id = ${alias}.${prop.name}Id`);
        
        const joinDec = declarations.filter((dec)=>dec.name==innerType)[0];

        if(joinDec!=null){
            const joinData = generateSelectStatementJoin(`${alias}_${prop.name}`, declarations, joinDec, enums, types);
            joinData.fields.forEach((field)=>{
                fields.push(field);
            });
            joinData.joins.forEach((join)=>{
                joins.push(join);
            });
        }
        
        }else if(isList==false){
            fields.push(`${alias}.${prop.name}`);
        }
    }
    
    return {
        fields,
        joins
    }
}

export const generateSelectStatement = (declarations: any[],declaration:any, enums: string[],  types: string[])=>{
    const state = generateSelectStatementJoin(null, declarations, declaration, enums, types);
    return `SELECT ${state.fields.join(",\r\n")} FROM ${classNameToTableName(declaration.name)} ${state.joins.join("\r\n ")}`;
}