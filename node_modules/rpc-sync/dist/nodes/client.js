"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateClientSchema = exports.generateClientSchemaFromJson = exports.generators = void 0;
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const url_1 = __importDefault(require("url"));
const fs_1 = __importDefault(require("fs"));
const reactTypeScript_1 = require("../generators/reactTypeScript/reactTypeScript");
const typeScript_1 = require("../generators/typeScript/typeScript");
const dart_1 = require("../generators/dart/dart");
const visualBasic_1 = require("../generators/visualBasic/visualBasic");
exports.generators = { ReactTypeScript: reactTypeScript_1.ReactTypeScript, TypeScript: typeScript_1.TypeScript, Dart: dart_1.Dart, VisualBasic: visualBasic_1.VisualBasic };
const fetchSchema = (schemaOptions) => {
    return new Promise((accept, reject) => {
        let srcUrl = schemaOptions.srcUrl;
        console.log("Fetching schema..", srcUrl);
        if (schemaOptions.secret !== null && schemaOptions.secret !== undefined) {
            if (!srcUrl.endsWith("/")) {
                srcUrl = srcUrl + "/";
            }
            srcUrl = srcUrl + schemaOptions.secret;
        }
        const uri = url_1.default.parse(srcUrl);
        const options = {
            host: uri.hostname,
            port: parseInt(uri.port),
            path: uri.path,
        };
        const req = (uri.protocol == "https:" ? https_1.default : http_1.default)
            .get(options, (res) => {
            res.setEncoding("utf8");
            let content = "";
            res.on("data", function (chunk) {
                content += chunk;
            });
            res.on("end", function () {
                if (res.statusCode != 200) {
                    reject(new Error(`Error ${res.statusCode} ${content}`));
                    return;
                }
                try {
                    const jobj = JSON.parse(content);
                    console.log("Processing schema..", schemaOptions.srcUrl);
                    let schemaVersion = (res.headers["schema-version"] || "").toString();
                    if (schemaVersion.length == 0) {
                        schemaVersion = "<version not detected>";
                    }
                    accept({
                        schema: jobj,
                        version: schemaVersion,
                    });
                }
                catch (ex) {
                    reject(ex);
                }
            });
        })
            .on("error", (err) => {
            reject(err);
        });
    });
};
const synchronizeSchema = (schemaOptions) => {
    return new Promise((accept, reject) => {
        fetchSchema(schemaOptions)
            .then((update) => __awaiter(void 0, void 0, void 0, function* () {
            accept(update);
        }))
            .catch((e) => {
            reject(e);
        });
    });
};
const generateClientSchemaFromJson = (schemaOptions, update) => {
    return new Promise((accept, reject) => {
        const schema = update.schema;
        schemaOptions.generator
            .getHeader(schemaOptions, update.version)
            .then((header) => {
            try {
                const keys = Object.keys(schema);
                let src = `// Auto generated using 'rpc-sync' do not edit directly\r// Target: ${schemaOptions.target}\r// Version: ${update.version}\r// Refreshed: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}\r\r// Docs: ${schemaOptions.docsUrl}\r// Source: ${schemaOptions.srcUrl}\r\r${header}
           
        `;
                if (schemaOptions.target == "VisualBasic") {
                    src = src.replace(new RegExp("// ", "g"), "'");
                }
                const enumNames = [];
                const typeNames = [];
                const decs = [];
                keys.forEach((key) => {
                    const def = schema[key];
                    def.declarations = def.declarations || [];
                    for (const dec of def.declarations) {
                        if (dec.isExported == true) {
                            dec.members = dec.members || [];
                            decs.push(dec);
                            typeNames.push(dec.name);
                        }
                    }
                });
                keys.forEach((key) => {
                    const def = schema[key];
                    def.declarations = def.declarations || [];
                    for (const dec of def.declarations) {
                        if (dec.isExported == true) {
                            dec.methods = dec.methods || [];
                            if (dec.methods.length > 0) {
                                if (key.length > 0) {
                                    typeNames.push(key);
                                }
                            }
                        }
                    }
                });
                //Generate enums
                keys.forEach((key) => {
                    const def = schema[key];
                    def.declarations = def.declarations || [];
                    for (const dec of def.declarations) {
                        if (dec.isExported == true) {
                            dec.members = dec.members || [];
                            if (dec.members.length > 0) {
                                enumNames.push(dec.name);
                                src =
                                    src +
                                        schemaOptions.generator.generateEnums(schemaOptions, dec);
                            }
                        }
                    }
                });
                const entities = [];
                //Generate classes
                keys.forEach((key) => {
                    const def = schema[key];
                    if (def.entity == true) {
                        def.declarations = def.declarations || [];
                        for (const dec of def.declarations) {
                            if (dec.isExported == true) {
                                dec.members = dec.members || [];
                                dec.properties = dec.properties || [];
                                if (dec.members.length == 0 && dec.properties.length > 0) {
                                    entities.push(dec["name"]);
                                    src =
                                        src +
                                            schemaOptions.generator.generateClassEntity(schemaOptions, dec, enumNames, typeNames, decs);
                                }
                            }
                        }
                    }
                });
                //Generate interfaces
                keys.forEach((key) => {
                    const def = schema[key];
                    if (def.entity != true) {
                        def.declarations = def.declarations || [];
                        for (const dec of def.declarations) {
                            if (dec.isExported == true) {
                                dec.properties = dec.properties || [];
                                dec.members = dec.members || [];
                                if (dec.properties.length > 0 ||
                                    (dec.properties.length == 0 &&
                                        dec.members.length == 0 &&
                                        dec.name.startsWith("I"))) {
                                    src =
                                        src +
                                            schemaOptions.generator.generateInterfaces(schemaOptions, dec, enumNames, typeNames);
                                }
                            }
                        }
                    }
                });
                const apis = [];
                //Generate APIs
                keys.forEach((key) => {
                    const def = schema[key];
                    if (def.entity != true) {
                        def.declarations = def.declarations || [];
                        for (const dec of def.declarations) {
                            if (dec.isExported == true) {
                                dec.methods = dec.methods || [];
                                if (dec.methods.length > 0) {
                                    dec["alias"] = key;
                                    apis.push(dec);
                                }
                            }
                        }
                    }
                });
                src =
                    src + schemaOptions.generator.generateMethods(schemaOptions, apis);
                src =
                    src +
                        schemaOptions.generator.generateFooter(schemaOptions, enumNames, typeNames, entities);
                fs_1.default.writeFile(schemaOptions.output, src, (err) => {
                    if (err) {
                        reject(err);
                        return;
                    }
                    accept();
                });
            }
            catch (e) {
                reject(e);
            }
        })
            .catch((e) => {
            reject(e);
        });
    });
};
exports.generateClientSchemaFromJson = generateClientSchemaFromJson;
const generateClientSchema = (config) => {
    return new Promise((accept, reject) => {
        config.target = config.target || "ReactTypeScript";
        if (config.generator == null) {
            config.generator = exports.generators[config.target];
        }
        if (config.generator == null) {
            reject(new Error(`Unsupported target ${config.target}`));
            return;
        }
        console.log("Target:", config.target);
        config.output = config.output || "";
        config.namespace = config.namespace || "RPC";
        config.url = config.url || "";
        if (config.url.length == 0) {
            reject(new Error(`[url] parameter missing in ${config.configName}`));
            return;
        }
        if (config.output.length == 0) {
            reject(new Error(`[output] parameter missing in ${config.configName}`));
            return;
        }
        if (!config.url.endsWith("/")) {
            config.url = `${config.url}/`;
        }
        config.srcUrl = config.srcUrl || "";
        config.docsUrl = config.docsUrl || "";
        if (config.srcUrl.length == 0) {
            config.srcUrl = `${config.url}json/`;
        }
        if (config.docsUrl.length == 0) {
            config.docsUrl = `${config.url}docs/`;
        }
        synchronizeSchema(config)
            .then((schema) => {
            (0, exports.generateClientSchemaFromJson)(config, schema)
                .then(() => {
                console.log(config.namespace, "generated:", config.output);
                if (config.destSchemaOutput == null) {
                    accept(schema);
                    return;
                }
                fs_1.default.writeFile(config.destSchemaOutput, config.destSchemaOutputPretty == true ? JSON.stringify(schema, null, 2) : JSON.stringify(schema), () => {
                    accept(schema);
                });
            })
                .catch((e) => {
                console.error(e);
                reject(e);
            });
        })
            .catch((e) => {
            console.error(e);
            reject(e);
        });
    });
};
exports.generateClientSchema = generateClientSchema;
//# sourceMappingURL=client.js.map