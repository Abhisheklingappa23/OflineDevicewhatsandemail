"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSelectStatement = exports.generateSelectStatementJoin = exports.generateCreateStatement = exports.classNameToTableName = void 0;
const primitives = ["string", "number", "boolean"];
const classNameToTableName = (className) => {
    let output = "";
    for (let i = 0; i < className.length; i++) {
        const isUpperCase = className[i].toUpperCase() == className[i];
        if (isUpperCase && output.length > 0) {
            output += "_" + className[i];
        }
        else {
            output += className[i];
        }
    }
    return output.toLowerCase();
};
exports.classNameToTableName = classNameToTableName;
const generateCreateStatement = (declaration, enums, types) => {
    let createFields = "";
    for (const prop of declaration.properties) {
        const type = prop.type;
        const innerType = prop.type.replace("[]", "");
        const isList = type.indexOf("[]") != -1;
        const isObject = (types.indexOf(type) != -1 || types.indexOf(innerType) != -1);
        const isPrimitive = (primitives.indexOf(type) == -1 && primitives.indexOf(innerType) == -1);
        let isEnum = false;
        if (isList == true) {
            isEnum = enums.indexOf(innerType) != -1;
        }
        else {
            isEnum = enums.indexOf(type) != -1;
        }
        if (createFields.length > 0) {
            createFields = createFields + ", ";
        }
        if (prop.name == "id") {
            createFields = createFields + `${prop.name} INTEGER PRIMARY KEY`;
        }
        else {
            if (isEnum) {
                createFields = createFields + `${prop.name} INTEGER`;
            }
            else if (isList) {
                //createFields = createFields + `${prop.name}Id INTEGER`;
            }
            else if (isObject == true && isPrimitive == false) {
                createFields = createFields + `${prop.name}Id INTEGER`;
            }
            else {
                createFields = createFields + `${prop.name} TEXT`;
            }
        }
    }
    return `CREATE TABLE ${(0, exports.classNameToTableName)(declaration.name)} (${createFields})`;
};
exports.generateCreateStatement = generateCreateStatement;
const generateSelectStatementJoin = (alias, declarations, declaration, enums, types) => {
    if (alias == null) {
        alias = (0, exports.classNameToTableName)(declaration.name);
    }
    const fields = [];
    const joins = [];
    for (const prop of declaration.properties) {
        const type = prop.type;
        const innerType = prop.type.replace("[]", "");
        const isList = type.indexOf("[]") != -1;
        const isObject = (types.indexOf(type) != -1 || types.indexOf(innerType) != -1);
        let isEnum = false;
        if (isList == true) {
            isEnum = enums.indexOf(innerType) != -1;
        }
        else {
            isEnum = enums.indexOf(type) != -1;
        }
        if (isList == false && isObject == true && isEnum == false) {
            const fieldAlias = `${alias}_${prop.name}`;
            // fields.push(`${fieldAlias}Id`);
            joins.push(`LEFT JOIN ${(0, exports.classNameToTableName)(innerType)} as ${fieldAlias} on ${fieldAlias}.id = ${alias}.${prop.name}Id`);
            const joinDec = declarations.filter((dec) => dec.name == innerType)[0];
            if (joinDec != null) {
                const joinData = (0, exports.generateSelectStatementJoin)(`${alias}_${prop.name}`, declarations, joinDec, enums, types);
                joinData.fields.forEach((field) => {
                    fields.push(field);
                });
                joinData.joins.forEach((join) => {
                    joins.push(join);
                });
            }
        }
        else if (isList == false) {
            fields.push(`${alias}.${prop.name}`);
        }
    }
    return {
        fields,
        joins
    };
};
exports.generateSelectStatementJoin = generateSelectStatementJoin;
const generateSelectStatement = (declarations, declaration, enums, types) => {
    const state = (0, exports.generateSelectStatementJoin)(null, declarations, declaration, enums, types);
    return `SELECT ${state.fields.join(",\r\n")} FROM ${(0, exports.classNameToTableName)(declaration.name)} ${state.joins.join("\r\n ")}`;
};
exports.generateSelectStatement = generateSelectStatement;
//# sourceMappingURL=sqlite.js.map