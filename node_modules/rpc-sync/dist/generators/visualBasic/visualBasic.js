"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VisualBasic = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typeMap = {
    "number": "Double",
    "unknown": "Object"
};
const typeKeys = Object.keys(typeMap);
const convertTypeToVB = (type) => {
    if (type == null) {
        type = "Object";
    }
    if (type.indexOf("{") != -1 || type.indexOf("}") != -1) {
        type = "Object";
    }
    if (type.indexOf(" ") != -1) {
        type = type.split(" ")[0];
    }
    if (type.split("<")[0] == "Record") {
        type = "Object";
    }
    const isArray = type.indexOf("[]") != -1;
    if (isArray == true)
        type = type.replace("[]", "");
    if (typeKeys.indexOf(type) != -1) {
        type = typeMap[type];
    }
    ;
    if (isArray) {
        type = `Generic.List(of ${type})`;
    }
    return type;
};
exports.VisualBasic = {
    getHeader(options, version) {
        return new Promise((accept, reject) => {
            fs_1.default.readFile(path_1.default.join(__dirname, "../../../src/generators/visualBasic/", "visualBasicTemplate.vb"), (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                accept(`Module Schema\r\npublic const schemaVersion as string = "${version}"\r\nEnd Module\r\n${data.toString("utf8")}`);
            });
        });
    },
    generateFooter(options, enums, types, generateFooter) {
        return "";
    },
    generateClassEntity(options, declaration, declarations) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}Public [${prop.name}] as ${convertTypeToVB(prop.type)}
        `;
        }
        let src = `
     Public Class ${declaration.name}
        ${props}
     End Class
    `;
        return src;
    },
    generateInterfaces(options, declaration) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}Public [${prop.name}] as ${convertTypeToVB(prop.type)}
        `;
        }
        let src = `
    Public Class ${declaration.name}
        ${props}
    End Class
    `;
        return src;
    },
    generateEnums(options, declaration) {
        let props = "";
        declaration.members = declaration.members || [];
        for (const member of declaration.members) {
            props = `${props}[${member}]
        `;
        }
        let src = `
    Public Enum ${declaration.name}
        ${props}
    End Enum
    `;
        return src;
    },
    generateMethods(options, apis) {
        let src = `
      Public Class [${options.namespace}]
   
  
        `;
        for (let a = 0; a < apis.length; a++) {
            const declaration = apis[a];
            declaration.methods = declaration.methods || [];
            src = src + `Public Class [${declaration.alias}API]
            `;
            for (let m = 0; m < declaration.methods.length; m++) {
                const method = declaration.methods[m];
                let props = "";
                for (let i = 0; i < method.parameters.length; i++) {
                    const param = method.parameters[i];
                    if (props.length > 0) {
                        props = `${props}, `;
                    }
                    props = `${props}${param.name} as ${param.type}`;
                }
                const mainParam = method.parameters[1] || { "name": "parameters" };
                let methodParamType = method.type;
                if (methodParamType.indexOf("Promise<") !== -1) {
                    methodParamType = methodParamType.substring(8);
                    methodParamType = methodParamType.substring(0, methodParamType.length - 1);
                }
                if (methodParamType != "void") {
                    src = src + `
    Public Shared Function [${method.name}](${props}) as ${convertTypeToVB(methodParamType)}
        return Utility.RequestHandler(Of ${convertTypeToVB(methodParamType)})(context, String.Format("{0}/{1}", "${declaration.alias}", "${method.name}"), parameters)
    End Function
    `;
                }
            }
            src = src + `
            End Class
    
        `;
        }
        src = src + `

    End Class`;
        return src;
    }
};
//# sourceMappingURL=visualBasic.js.map