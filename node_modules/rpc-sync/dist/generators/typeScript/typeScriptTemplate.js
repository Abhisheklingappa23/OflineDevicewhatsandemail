"use strict";
/* eslint-disable  @typescript-eslint/no-explicit-any */
/* eslint-disable  @typescript-eslint/no-unused-vars */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestStatus = exports.ErrorWithStatusCode = void 0;
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const url_1 = __importDefault(require("url"));
class ErrorWithStatusCode extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
    }
}
exports.ErrorWithStatusCode = ErrorWithStatusCode;
var RequestStatus;
(function (RequestStatus) {
    RequestStatus[RequestStatus["idle"] = 0] = "idle";
    RequestStatus[RequestStatus["loading"] = 1] = "loading";
    RequestStatus[RequestStatus["loaded"] = 2] = "loaded";
    RequestStatus[RequestStatus["error"] = 3] = "error";
})(RequestStatus = exports.RequestStatus || (exports.RequestStatus = {}));
const createContext = (context, alias, method) => {
    const subContext = Object.assign({}, context);
    if (subContext.url.endsWith("/") === false) {
        subContext.url = subContext.url + "/";
    }
    subContext.url = subContext.url + alias + "/" + method + "/";
    return subContext;
};
const decodeResult = (value) => {
    if (value !== null && value !== undefined) {
        if (value.hasOwnProperty("primitive")) {
            return value["primitive"];
        }
    }
    return value;
};
const defaultRequestHandler = (context, schemaVersion, parameters, accept, reject) => {
    parameters = parameters || {};
    const data = JSON.stringify(parameters);
    const uri = url_1.default.parse(context.url);
    const options = {
        host: uri.hostname,
        port: parseInt(uri.port || ""),
        path: uri.path,
        method: "POST",
        headers: Object.assign({
            'Content-Type': 'application/json',
            'Content-Length': data.length,
            'schema-version': schemaVersion,
            'User-Agent': 'rpc',
            'timestamp': new Date().toISOString()
        }, context.headers || {}),
    };
    const request = (uri.protocol === "https:" ? https_1.default : http_1.default).request(options, (res) => {
        res.setEncoding("utf8");
        let content = "";
        res.on("data", function (chunk) {
            content += chunk;
        });
        res.on("end", function () {
            const serverSchemaVersion = (res.headers["schema-version"] || "").toString();
            if (serverSchemaVersion.length > 0) {
                if (serverSchemaVersion !== schemaVersion) {
                    console.warn("Client schema is out of date. The server is running a different version of the API. Server:", serverSchemaVersion, "Client:", schemaVersion);
                }
            }
            let jobj;
            try {
                jobj = JSON.parse(content);
            }
            catch (ex) {
                jobj = null;
                if (res.statusCode == 200) {
                    reject(new ErrorWithStatusCode(ex.message, res.statusCode));
                    return;
                }
            }
            if (res.statusCode !== 200) {
                if (jobj == null) {
                    jobj = { error: res.statusMessage };
                }
                reject(new ErrorWithStatusCode(jobj.error, res.statusCode));
                return;
            }
            try {
                accept(jobj);
            }
            catch (ex) {
                reject(new ErrorWithStatusCode(ex.message, res.statusCode));
            }
        });
    }).on("error", (err) => {
        reject(new ErrorWithStatusCode(err.message, 0));
    });
    request.write(data);
    request.end();
};
//# sourceMappingURL=typeScriptTemplate.js.map