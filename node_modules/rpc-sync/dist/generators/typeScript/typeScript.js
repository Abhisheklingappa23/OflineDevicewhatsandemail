"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeScript = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
exports.TypeScript = {
    getHeader(options, version) {
        return new Promise((accept, reject) => {
            fs_1.default.readFile(path_1.default.join(__dirname, "../../../src/generators/typeScript/", "TypeScriptTemplate.ts"), (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                accept(`export const schemaVersion = "${version}";\r\r${data.toString("utf8")}`);
            });
        });
    },
    generateFooter(options, enums, types, generateFooter) {
        return "";
    },
    generateClassEntity(options, declaration, enums, declarations) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}${prop.name}${prop.isOptional == true ? "?" : ""}:${prop.type};
        `;
        }
        let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateInterfaces(options, declaration, enums) {
        let props = "";
        declaration.properties = declaration.properties || [];
        for (const prop of declaration.properties) {
            props = `${props}${prop.name}${prop.isOptional == true ? "?" : ""}:${prop.type};
        `;
        }
        let src = `
    export interface ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateEnums(options, declaration) {
        let props = "";
        declaration.members = declaration.members || [];
        for (const member of declaration.members) {
            props = `${props}${member},
        `;
        }
        let src = `
    export enum ${declaration.name}{
        ${props}
    }
    `;
        return src;
    },
    generateMethods(options, apis) {
        let src = `
    export const ${options.namespace} = {

        requests:{
        `;
        for (let a = 0; a < apis.length; a++) {
            const declaration = apis[a];
            declaration.methods = declaration.methods || [];
            src =
                src +
                    `${declaration.alias}:{
            `;
            for (let m = 0; m < declaration.methods.length; m++) {
                const method = declaration.methods[m];
                let props = "";
                for (let i = 0; i < method.parameters.length; i++) {
                    const param = method.parameters[i];
                    if (props.length > 0) {
                        props = `${props}, `;
                    }
                    props = `${props}${param.name}: ${param.type}`;
                }
                const mainParam = method.parameters[1] || { name: "parameters" };
                src =
                    src +
                        `
            ${method.name}:(${props}) : ${method.type} => {
                return new ${method.type}((a, r)=>(context.requestHandler || defaultRequestHandler)(createContext(context, "${declaration.alias}","${method.name}"),schemaVersion, ${mainParam.name}, (v)=>{a(decodeResult(v))}, r));
            }${m != declaration.methods.length - 1 ? "," : ""}
            `;
            }
            src =
                src +
                    `
        }${a != apis.length - 1 ? "," : ""}
    
        `;
        }
        src =
            src +
                `
       
    }
};
`;
        return src;
    },
};
//# sourceMappingURL=typeScript.js.map